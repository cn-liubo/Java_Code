解法1：暴力破解

```java
public class Solution {
    public boolean isPalindromic(String s) {
    	int len = s.length();
        for(int i = 0; i < len / 2; i++) {
            if(s.charAt(i) != s.charAt(len - i - 1)) {
                return false;
            }
        }
        return true;
    }
    
    public String longestPalindrome(String s) {
        string ans = "";
        int max = 0;
        int len = s.length();
        for(int i = 0; i < len; i++) {
            for(int j = i + 1; j <= len; j++) {
                String tmp = s.substring(i, j);
                if(isPalindromic(temp) && tmp.length() > max) {
                    ans = s.substring(i, j);
                    max = Math.max(max, ans.length())
                }
            }
        }
        return ans;
    }
}
```

```java
public class Solution {
    public boolean isPalindromic(char[] charArr, int left, int right) {
    	while(left < right) {
            if(charArr[left] != charArr[right]) {
                return false;
            }
            left++;
            right--;
        }
        return true;
    }
    
    public String longestPalindrome(String s) {
        int len = s.length();
        if(len < 2) return s;
        
        int maxLen = 1;//最长回文子串的长度
        int begin = 0;//最长回文子串的起始下标
        //s.charAt(i)每次都会检查数组下标越界，因此先转换成字符串数组，这一步非必须
        char[] charArr = s.toCharArray();
        
        //枚举所有长度严格大于1的字串，charArr[i ... j]
        for(int i = 0; i < len - 1; i++) {
            for(int j = i + 1; j < len; j++) {
                //当前子串的长度超过此时最大的回文子串，并且当前子串是回文子串
                if(j - i + 1 > maxLen && isPalindromic(charArr, i, j)) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}
```



解法2：中心扩散法

```java
public class Solution {
    public String longestPalindrome(String str) {
        int len = s.legnth();
        if(len < 2) {
            reutrn s;
        }
        
        int maxLen = 1;
        int begin = 0;
        char[] charArr = s.toCharArray();
        for(int i = 0; i < len - 1; i++) {
            int len1 = expandAroundCenter(charArr, i, i);
            int len2 = expandAroundCenter(charArr, i, i+ 1);
            int curMaxLen = Math.max(len1, len2);
            if(curMaxLen > maxLen) {
                maxLen = curMaxLen;
                begin = i - (maxLen - 1) / 2;//根据奇数回文串和偶数回文串得到的统一的表达式
            }
        }
        return s.substring(begin, begin + maxLen);
    }
    
    public int expandAroundCenter(char[] charArr, int left, int right) {
        //当left = right时，回文中心是一个字符，回文串的长度是奇数
        //当right = left+1时，此时回文中心两个字符，回文串的长度时偶数
        int len = charArr.length;
        int i = left;
        int j = right;
        while(i >= 0 && j < len) {
            if(charArr[i] == charArr[j]) {
                i--;
                j++;
            } else {
                break;
            }
        }
        //跳出while循环时，恰好满足s.charAt(i) != s.charAt(j)
        //回文串的长度是j-i+1-2 = j-i-1
        return j - i - 1;
    }
}
```

解法3：动态规划

```jav

```

